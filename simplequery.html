<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Response Time Lookup</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .input-group {
            margin-bottom: 20px;
        }
        .input-group label {
            margin-right: 10px;
        }
        .query-info {
            margin: 10px 0;
            padding: 10px;
            background-color: #f8f8f8;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
            display: none;
        }
        .show-query-btn {
            margin-left: 10px;
            padding: 5px 10px;
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
        }
        .show-query-btn:hover {
            background-color: #e0e0e0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        th, td {
            padding: 10px;
            border: 1px solid #000000;
            text-align: left;
        }
        th {
            background-color: #f5f5f5;
        }
        tr:nth-child(even) {
            background-color: #fafafa;
        }
        .priority-1 { background-color: rgba(144, 238, 144, 0.2); }
        .priority-2 { background-color: rgba(255, 182, 193, 0.2); }
        .priority-3 { background-color: rgba(147, 112, 219, 0.2); }
        .priority-4 { background-color: rgba(100, 149, 237, 0.2); }
        .priority-5 { background-color: rgba(255, 192, 203, 0.2); }
        .priority-7 { background-color: rgba(176, 196, 222, 0.2); }
        .priority-9 { background-color: rgba(255, 105, 180, 0.2); }
        .loading {
            text-align: center;
            margin: 20px;
            font-style: italic;
            color: #666;
        }
        .error {
            text-align: center;
            margin: 20px;
            font-style: italic;
            color: #ff0000;
        }
    </style>
</head>
<body>
    <h2>Seattle Dispatch Response Time Lookup</h2>
    <div class="input-group">
        <label for="startDate">Start Date:</label>
        <input type="date" id="startDate">
        <label for="endDate">End Date:</label>
        <input type="date" id="endDate">
        <label for="dispatchBeat">Dispatch Beats (comma-separated):</label>
        <input type="text" id="dispatchBeat" placeholder="e.g., B1, C2">
        <button onclick="fetchData()">Get Response Times</button>
        <button class="show-query-btn" onclick="toggleQuery()">Show API Query</button>
    </div>
    
    <div id="query-display" class="query-info"></div>
    <div id="results"></div>

    <script>
        let currentQueries = [];

        function toggleQuery() {
            const queryDisplay = document.getElementById('query-display');
            if (queryDisplay.style.display === 'none' || !queryDisplay.style.display) {
                if (currentQueries.length > 0) {
                    queryDisplay.innerHTML = currentQueries.map((q, i) => 
                        `<strong>${i === 0 ? 'Count Query:' : 'Data Query:'}</strong>\n${apiUrl}${q}\n`
                    ).join('\n\n');
                    queryDisplay.style.display = 'block';
                } else {
                    queryDisplay.innerHTML = 'No queries have been made yet. Run a search first.';
                    queryDisplay.style.display = 'block';
                }
            } else {
                queryDisplay.style.display = 'none';
            }
        }

        async function fetchData() {
            currentQueries = []; // Reset queries
            const startDate = document.getElementById("startDate").value;
            const endDate = document.getElementById("endDate").value;
            const dispatchBeats = document.getElementById("dispatchBeat").value.toUpperCase().split(',').map(b => b.trim());
            
            if (!startDate || !endDate || dispatchBeats.length === 0 || dispatchBeats[0] === "") {
                alert("Please enter all fields.");
                return;
            }

            const resultsDiv = document.getElementById("results");
            resultsDiv.innerHTML = '<div class="loading">Calculating query size...</div>';
            
            const datasetId = "33kz-ixgy";
            const apiUrl = `https://data.seattle.gov/resource/${datasetId}.json`;
            let beatStats = {};

            // Get a rough count first
            let totalCount = 0;
            for (let beat of dispatchBeats) {
                const countQuery = `?$select=count(*) as count&$where=` +
                    `cad_event_original_time_queued >= '${startDate}T00:00:00' AND ` +
                    `cad_event_original_time_queued <= '${endDate}T23:59:59' AND ` +
                    `dispatch_beat='${beat}' AND ` +
                    `initial_call_type != 'ONVIEW' AND ` +
                    `initial_call_type != 'BACKUPONLY' AND ` +
                    `initial_call_type != 'BACKUPONLY-URGENT'`;
                
                currentQueries[0] = countQuery; // Store count query
                try {
                    const response = await fetch(apiUrl + countQuery);
                    const data = await response.json();
                    if (data && data[0] && data[0].count) {
                        totalCount += Number(data[0].count);
                    }
                } catch (error) {
                    console.warn("Count estimation failed, proceeding anyway");
                }
            }

            // Calculate rough time estimate (1 second per 1000 records plus API delays)
            if (totalCount > 0) {
                const estimatedSeconds = Math.ceil(totalCount / 1000) + 1;
                let remainingTime = estimatedSeconds;

                function updateCountdown() {
                    const minutes = Math.floor(remainingTime / 60);
                    const seconds = remainingTime % 60;
                    const timeText = minutes > 0 ? 
                        `${minutes} minute${minutes > 1 ? 's' : ''} and ${seconds} second${seconds !== 1 ? 's' : ''}` : 
                        `${seconds} second${seconds !== 1 ? 's' : ''}`;

                    resultsDiv.innerHTML = `<div class="loading">
                        Fetching ${totalCount.toLocaleString()} records<br>
                        <small>Estimated time remaining: ${timeText}</small>
                    </div>`;
                }

                // Initial display
                updateCountdown();

                try {
                    for (let beat of dispatchBeats) {
                        let offset = 0;
                        let allData = [];
                        let priorityGroups = {};
                        
                        while (true) {
                            const query = `?$where=cad_event_original_time_queued >= '${startDate}T00:00:00' AND ` +
                                `cad_event_original_time_queued <= '${endDate}T23:59:59' AND ` +
                                `dispatch_beat='${beat}' AND ` +
                                `initial_call_type != 'ONVIEW' AND ` +
                                `initial_call_type != 'BACKUPONLY' AND ` +
                                `initial_call_type != 'BACKUPONLY-URGENT'` +
                                `&$limit=1000&$offset=${offset}`;
                            
                            currentQueries[1] = query; // Store data query
                            try {
                                const response = await fetch(apiUrl + query);
                                const data = await response.json();
                                if (!data || data.length === 0) break;
                                allData = allData.concat(data);
                                offset += 1000;

                                // Update countdown and wait 1 second
                                remainingTime = Math.max(0, remainingTime - 1);
                                updateCountdown();
                                await new Promise(resolve => setTimeout(resolve, 1000));
                            } catch (error) {
                                console.error("Error fetching data:", error);
                                alert("Failed to fetch data for beat " + beat);
                                break;
                            }
                        }

                        // Process data for this beat
                        beatStats[beat] = {
                            totalCalls: allData.length,
                            priorities: {}
                        };

                        allData.forEach(d => {
                            if (d.cad_event_first_response_time_s_ && d.priority) {
                                const responseTimeSeconds = Number(d.cad_event_first_response_time_s_);
                                
                                // Filter out unreasonably large times (> 24 hours) and negative times
                                if (responseTimeSeconds > 0 && responseTimeSeconds < 86400) {
                                    if (!priorityGroups[d.priority]) {
                                        priorityGroups[d.priority] = [];
                                    }
                                    priorityGroups[d.priority].push(responseTimeSeconds);
                                }
                            }
                        });

                        // Calculate statistics for each priority
                        for (let priority in priorityGroups) {
                            const times = priorityGroups[priority];
                            if (times.length > 0) {
                                const sortedTimes = [...times].sort((a, b) => a - b);
                                beatStats[beat].priorities[priority] = {
                                    count: times.length,
                                    mean: times.reduce((a, b) => a + b, 0) / times.length,
                                    median: sortedTimes.length % 2 === 0 ? 
                                        (sortedTimes[sortedTimes.length / 2 - 1] + sortedTimes[sortedTimes.length / 2]) / 2 :
                                        sortedTimes[Math.floor(sortedTimes.length / 2)],
                                    min: sortedTimes[0],
                                    max: sortedTimes[sortedTimes.length - 1]
                                };
                            }
                        }
                    }
                } finally {
                    // Show completion
                    resultsDiv.innerHTML = '<div class="loading">Processing results...</div>';
                }

                displayResults(beatStats);
            } else {
                resultsDiv.innerHTML = '<div class="loading">Fetching data...</div>';
                // Continue with data fetching even if count estimation failed
                // ... rest of the data fetching code ...
            }
        }
        
        function formatTime(seconds) {
            if (!seconds) return 'N/A';
            
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            
            if (hours > 0) {
                return `${hours}h ${minutes}m ${secs}s`;
            } else if (minutes > 0) {
                return `${minutes}m ${secs}s`;
            } else {
                return `${secs}s`;
            }
        }
        
        function displayResults(beatStats) {
            const resultsDiv = document.getElementById("results");
            const allPriorities = new Set();
            Object.values(beatStats).forEach(beat => {
                Object.keys(beat.priorities).forEach(priority => allPriorities.add(priority));
            });
            const sortedPriorities = [...allPriorities].sort((a, b) => Number(a) - Number(b));
            
            let html = `
                <h3>Results (Community-Generated Calls Only)</h3>
                <p style="color: #666; font-style: italic; margin-bottom: 20px;">
                    Showing official SPD response times for community-generated calls only. Response time is measured from call receipt to first unit arrival on scene. 
                    Excludes officer-initiated (ONVIEW) and backup-only calls.
                </p>
                <table>
                    <tr>
                        <th>Priority</th>
                        ${Object.keys(beatStats).map(beat => `<th colspan="4">${beat}</th>`).join('')}
                    </tr>
                    <tr>
                        <th></th>
                        ${Object.keys(beatStats).map(() => `
                            <th>Count</th>
                            <th>Mean</th>
                            <th>Median</th>
                            <th>Range</th>
                        `).join('')}
                    </tr>`;
            
            sortedPriorities.forEach(priority => {
                html += `
                    <tr class="priority-${priority}">
                        <td><strong>Priority ${priority}</strong></td>
                        ${Object.keys(beatStats).map(beat => {
                            const stats = beatStats[beat].priorities[priority];
                            if (!stats) return '<td colspan="4">No data</td>';
                            return `
                                <td>${stats.count}</td>
                                <td>${formatTime(stats.mean)}</td>
                                <td>${formatTime(stats.median)}</td>
                                <td>${formatTime(stats.min)} - ${formatTime(stats.max)}</td>
                            `;
                        }).join('')}
                    </tr>`;
            });
            
            html += `
                    <tr>
                        <td><strong>Total Calls</strong></td>
                        ${Object.keys(beatStats).map(beat => `
                            <td colspan="4">${beatStats[beat].totalCalls}</td>
                        `).join('')}
                    </tr>
                </table>`;
            
            resultsDiv.innerHTML = html;
        }
    </script>
</body>
</html>

