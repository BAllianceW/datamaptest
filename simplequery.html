<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Response Time Lookup</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .input-group {
            margin-bottom: 20px;
        }
        .input-group label {
            margin-right: 10px;
        }
        .query-info {
            margin: 10px 0;
            padding: 10px;
            background-color: #f8f8f8;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
            display: none;
        }
        .show-query-btn {
            margin-left: 10px;
            padding: 5px 10px;
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
        }
        .show-query-btn:hover {
            background-color: #e0e0e0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        th, td {
            padding: 10px;
            border: 1px solid #000000;
            text-align: left;
        }
        th {
            background-color: #f5f5f5;
        }
        tr:nth-child(even) {
            background-color: transparent;
        }
        .priority-1 { background-color: rgba(232, 74, 95, 0.6) !important; }
        .priority-2 { background-color: rgba(239, 82, 87, 0.6) !important; }
        .priority-3 { background-color: rgba(245, 91, 79, 0.6) !important; }
        .priority-4 { background-color: rgba(250, 100, 70, 0.6) !important; }
        .priority-5 { background-color: rgba(253, 111, 60, 0.6) !important; }
        .priority-7 { background-color: rgba(255, 122, 48, 0.6) !important; }
        .priority-9 { background-color: rgba(255, 134, 34, 0.6) !important; }
        .loading {
            text-align: center;
            margin: 20px;
            font-style: italic;
            color: #666;
        }
        .error {
            text-align: center;
            margin: 20px;
            font-style: italic;
            color: #ff0000;
        }
        .expandable-button {
            cursor: pointer;
            padding: 2px 6px;
            margin-left: 10px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-size: 0.8em;
            background-color: #f8f8f8;
        }
        .expandable-row {
            display: none;
            background-color: #f8f8f8;
        }
        .expandable-row td {
            padding-left: 30px;
            font-size: 0.95em;
        }
        .onview-row { 
            background-color: #f8f8f8 !important;
        }
        .backup-row { background-color: rgba(100, 149, 237, 0.1); }
        .backup-urgent-row { background-color: rgba(255, 140, 0, 0.1); }
        
        /* Map Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.4);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 800px;
            border-radius: 4px;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover {
            color: black;
        }

        #map {
            height: 600px;
            width: 100%;
            margin: 10px 0;
        }

        .map-button {
            margin-left: 10px;
            padding: 5px 10px;
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
        }

        .beat-label {
            background: none;
            border: none;
            box-shadow: none;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h2>Seattle Dispatch Response Time Lookup</h2>
    <div class="input-group">
        <label for="startDate">Start Date:</label>
        <input type="date" id="startDate">
        <label for="endDate">End Date:</label>
        <input type="date" id="endDate">
        <label for="dispatchBeat">Dispatch Beats (comma-separated):</label>
        <input type="text" id="dispatchBeat" placeholder="e.g., B1, C2">
        <button class="map-button" onclick="openMapSelector()">Select Dispatch Beat(s)<br>from Map</button>
        <button onclick="fetchData()">Get Response Times</button>
        <button class="show-query-btn" onclick="toggleQuery()">Show API Query</button>
    </div>
    
    <div id="query-display" class="query-info"></div>
    <div id="results"></div>

    <!-- Add Map Modal -->
    <div id="mapModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeMapSelector()">&times;</span>
            <h3>Select Beats from Map</h3>
            <div id="map"></div>
            <div style="margin-top: 10px; text-align: right;">
                <button onclick="applyBeatSelection()" style="margin-right: 10px;">Apply Selection</button>
                <button onclick="closeMapSelector()">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        let currentQueries = [];
        const datasetId = "33kz-ixgy";
        const apiUrl = `https://data.seattle.gov/resource/${datasetId}.json`;
        let map = null;
        let beatLayers = {};
        let selectedBeats = new Set();

        function toggleQuery() {
            const queryDisplay = document.getElementById('query-display');
            if (queryDisplay.style.display === 'none' || !queryDisplay.style.display) {
                if (currentQueries.length > 0) {
                    queryDisplay.innerHTML = currentQueries.map((q, i) => 
                        `<strong>${i === 0 ? 'Count Query:' : 'Data Query:'}</strong>\n${apiUrl}${q}\n`
                    ).join('\n\n');
                    queryDisplay.style.display = 'block';
                } else {
                    queryDisplay.innerHTML = 'No queries have been made yet. Run a search first.';
                    queryDisplay.style.display = 'block';
                }
            } else {
                queryDisplay.style.display = 'none';
            }
        }

        async function fetchData() {
            currentQueries = []; // Reset queries
            const startDate = document.getElementById("startDate").value;
            const endDate = document.getElementById("endDate").value;
            const dispatchBeats = document.getElementById("dispatchBeat").value.toUpperCase().split(',').map(b => b.trim());
            
            if (!startDate || !endDate || dispatchBeats.length === 0 || dispatchBeats[0] === "") {
                alert("Please enter all fields.");
                return;
            }

            const resultsDiv = document.getElementById("results");
            resultsDiv.innerHTML = '<div class="loading">Calculating query size...</div>';
            
            let beatStats = {};

            // Get a rough count first
            let totalCount = 0;
            for (let beat of dispatchBeats) {
                const countQuery = `?$select=count(*) as count&$where=` +
                    `cad_event_original_time_queued >= '${startDate}T00:00:00' AND ` +
                    `cad_event_original_time_queued <= '${endDate}T23:59:59' AND ` +
                    `dispatch_beat='${beat}'`;
                
                currentQueries[0] = countQuery; // Store count query
                try {
                    const response = await fetch(apiUrl + countQuery);
                    const data = await response.json();
                    if (data && data[0] && data[0].count) {
                        totalCount += Number(data[0].count);
                    }
                } catch (error) {
                    console.warn("Count estimation failed, proceeding anyway");
                }
            }

            // Calculate rough time estimate (1 second per 1000 records plus API delays)
            if (totalCount > 0) {
                const estimatedSeconds = Math.ceil(totalCount / 1000) + 1;
                let remainingTime = estimatedSeconds;

                function updateCountdown() {
                    const minutes = Math.floor(remainingTime / 60);
                    const seconds = remainingTime % 60;
                    const timeText = minutes > 0 ? 
                        `${minutes} minute${minutes > 1 ? 's' : ''} and ${seconds} second${seconds !== 1 ? 's' : ''}` : 
                        `${seconds} second${seconds !== 1 ? 's' : ''}`;

                    resultsDiv.innerHTML = `<div class="loading">
                        Fetching ${totalCount.toLocaleString()} records<br>
                        <small>Estimated time remaining: ${timeText}</small>
                    </div>`;
                }

                // Initial display
                updateCountdown();

                try {
                    for (let beat of dispatchBeats) {
                        let offset = 0;
                        let allData = [];
                        let priorityGroups = {};
                        let specialGroups = {
                            ONVIEW: {},
                            BACKUP: {},
                            'BACKUP-URGENT': {}
                        };
                        
                        while (true) {
                            const query = `?$where=cad_event_original_time_queued >= '${startDate}T00:00:00' AND ` +
                                `cad_event_original_time_queued <= '${endDate}T23:59:59' AND ` +
                                `dispatch_beat='${beat}'` +
                                `&$limit=1000&$offset=${offset}`;
                            
                            // Only store the first query for display
                            if (offset === 0) {
                                currentQueries[1] = query;
                            }
                            try {
                                const response = await fetch(apiUrl + query);
                                const data = await response.json();
                                if (!data || data.length === 0) break;
                                allData = allData.concat(data);
                                offset += 1000;

                                remainingTime = Math.max(0, remainingTime - 1);
                                updateCountdown();
                                await new Promise(resolve => setTimeout(resolve, 1000));
                            } catch (error) {
                                console.error("Error fetching data:", error);
                                alert("Failed to fetch data for beat " + beat);
                                break;
                            }
                        }

                        // Process data for this beat
                        console.log(`Processing ${allData.length} records for beat ${beat}`);
                        
                        beatStats[beat] = {
                            totalCalls: 0,
                            priorities: {},
                            specialCategories: {
                                ONVIEW: {}
                            },
                            onviewExamples: {} // Store example call types for each priority
                        };

                        // Debug counters
                        let debugCounts = {
                            total: 0,
                            withResponseTime: 0,
                            validTimes: 0,
                            byType: {
                                DISPATCH: 0,
                                ONVIEW: 0
                            }
                        };

                        // First, categorize all data by call type and priority
                        allData.forEach(d => {
                            debugCounts.total++;
                            
                            if (d.cad_event_first_response_time_s_ && d.priority) {
                                debugCounts.withResponseTime++;
                                const responseTimeSeconds = Number(d.cad_event_first_response_time_s_);
                                
                                if (responseTimeSeconds > 0 && responseTimeSeconds < 86400) {
                                    debugCounts.validTimes++;
                                    
                                    // Debug logging for Priority 7 calls
                                    if (d.priority === '7') {
                                        console.log('Priority 7 call:', {
                                            call_type_indicator: d.call_type_indicator,
                                            initial_call_type: d.initial_call_type,
                                            final_call_type: d.final_call_type,
                                            responseTime: responseTimeSeconds
                                        });
                                    }
                                    
                                    // Use call_type_indicator to categorize
                                    if (d.call_type_indicator === 'ONVIEW') {
                                        debugCounts.byType.ONVIEW++;
                                        if (!beatStats[beat].specialCategories.ONVIEW[d.priority]) {
                                            beatStats[beat].specialCategories.ONVIEW[d.priority] = [];
                                            beatStats[beat].onviewExamples[d.priority] = new Set();
                                        }
                                        beatStats[beat].specialCategories.ONVIEW[d.priority].push(responseTimeSeconds);
                                        if (d.final_call_type) {
                                            beatStats[beat].onviewExamples[d.priority].add(d.final_call_type);
                                        }
                                    }
                                    if (d.call_type_indicator === 'DISPATCH') {
                                        debugCounts.byType.DISPATCH++;
                                        if (!beatStats[beat].priorities[d.priority]) {
                                            beatStats[beat].priorities[d.priority] = [];
                                        }
                                        beatStats[beat].priorities[d.priority].push(responseTimeSeconds);
                                        beatStats[beat].totalCalls++; // Only count dispatched calls in total
                                    } else {
                                        // Debug unknown call types
                                        console.log('Unknown call type indicator:', d.call_type_indicator, 'for priority:', d.priority);
                                    }
                                }
                            }
                        });

                        console.log('Debug counts:', debugCounts);
                        console.log(`Beat ${beat} categories:`, {
                            dispatch: Object.keys(beatStats[beat].priorities).length > 0 ? 
                                Object.keys(beatStats[beat].priorities) : 'No dispatch calls',
                            onview: Object.keys(beatStats[beat].specialCategories.ONVIEW).length > 0 ? 
                                Object.keys(beatStats[beat].specialCategories.ONVIEW) : 'No onview calls'
                        });

                        // Calculate statistics for regular calls
                        for (let priority in beatStats[beat].priorities) {
                            const times = beatStats[beat].priorities[priority];
                            if (times.length > 0) {
                                beatStats[beat].priorities[priority] = calculateStats(times);
                                console.log(`Priority ${priority} stats:`, beatStats[beat].priorities[priority]);
                            }
                        }

                        // Calculate statistics for special categories
                        for (let category in beatStats[beat].specialCategories) {
                            console.log(`Processing special category: ${category}`);
                            for (let priority in beatStats[beat].specialCategories[category]) {
                                const times = beatStats[beat].specialCategories[category][priority];
                                if (times && times.length > 0) {
                                    beatStats[beat].specialCategories[category][priority] = calculateStats(times);
                                    console.log(`${category} Priority ${priority} stats:`, 
                                        beatStats[beat].specialCategories[category][priority]);
                                }
                            }
                        }

                        console.log(`Completed processing beat ${beat}`);
                    }
                } finally {
                    // Show completion
                    resultsDiv.innerHTML = '<div class="loading">Processing results...</div>';
                }

                displayResults(beatStats);
            } else {
                resultsDiv.innerHTML = '<div class="loading">Fetching data...</div>';
                // Continue with data fetching even if count estimation failed
                // ... rest of the data fetching code ...
            }
        }
        
        function formatTime(seconds) {
            if (!seconds) return 'N/A';
            
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            
            if (hours > 0) {
                return `${hours}h ${minutes}m ${secs}s`;
            } else if (minutes > 0) {
                return `${minutes}m ${secs}s`;
            } else {
                return `${secs}s`;
            }
        }
        
        function calculateStats(times) {
            const sortedTimes = [...times].sort((a, b) => a - b);
            return {
                count: times.length,
                mean: times.reduce((a, b) => a + b, 0) / times.length,
                median: sortedTimes.length % 2 === 0 ? 
                    (sortedTimes[sortedTimes.length / 2 - 1] + sortedTimes[sortedTimes.length / 2]) / 2 :
                    sortedTimes[Math.floor(sortedTimes.length / 2)],
                min: sortedTimes[0],
                max: sortedTimes[sortedTimes.length - 1]
            };
        }

        function toggleRows(priority) {
            const rows = document.querySelectorAll(`.expandable-row-${priority}`);
            const button = document.querySelector(`#toggle-${priority}`);
            const isExpanding = rows[0].style.display === 'none';
            
            rows.forEach(row => {
                row.style.display = isExpanding ? 'table-row' : 'none';
            });
            
            if (button) {
                button.textContent = isExpanding ? '-' : '+';
            }
        }
        
        function displayResults(beatStats) {
            console.log('Displaying results for beats:', Object.keys(beatStats));
            const resultsDiv = document.getElementById("results");
            const allPriorities = new Set();
            Object.values(beatStats).forEach(beat => {
                Object.keys(beat.priorities).forEach(priority => allPriorities.add(priority));
            });
            const sortedPriorities = [...allPriorities].sort((a, b) => Number(a) - Number(b));
            
            let html = `
                <h3>Results (Dispatch Calls)</h3>
                <p style="color: #666; font-style: italic; margin-bottom: 20px;">
                    Showing official SPD response times for dispatch calls only. Response time is measured from call receipt to first unit arrival on scene. 
                    Click the + button next to each priority level to see officer-initiated (ONVIEW) calls.
                </p>
                <table>
                    <tr>
                        <th>Priority</th>
                        ${Object.keys(beatStats).map(beat => `<th colspan="4">${beat}</th>`).join('')}
                    </tr>
                    <tr>
                        <th></th>
                        ${Object.keys(beatStats).map(() => `
                            <th>Count</th>
                            <th>Mean</th>
                            <th>Median</th>
                            <th>Range</th>
                        `).join('')}
                    </tr>`;
            
            sortedPriorities.forEach(priority => {
                console.log(`Rendering priority ${priority}`);
                html += `
                    <tr class="priority-${priority}">
                        <td>
                            <strong>Priority ${priority}</strong>
                            <button id="toggle-${priority}" class="expandable-button" onclick="toggleRows('${priority}')">+</button>
                        </td>
                        ${Object.keys(beatStats).map(beat => {
                            const stats = beatStats[beat].priorities[priority];
                            console.log(`Priority ${priority} stats for beat ${beat}:`, stats);
                            if (!stats) return '<td colspan="4">No records</td>';
                            return `
                                <td>${stats.count.toLocaleString()}</td>
                                <td>${formatTime(stats.mean)}</td>
                                <td>${formatTime(stats.median)}</td>
                                <td>${formatTime(stats.min)} - ${formatTime(stats.max)}</td>
                            `;
                        }).join('')}
                    </tr>`;

                // Add expandable rows for ONVIEW category only
                html += `
                    <tr class="expandable-row expandable-row-${priority} onview-row">
                        <td>ONVIEW</td>
                        ${Object.keys(beatStats).map(beat => {
                            const stats = beatStats[beat].specialCategories.ONVIEW[priority];
                            console.log(`ONVIEW stats for beat ${beat}, priority ${priority}:`, stats);
                            if (!stats) return '<td colspan="4">No records</td>';
                            return `
                                <td>${stats.count.toLocaleString()}</td>
                                <td>${formatTime(stats.mean)}</td>
                                <td>${formatTime(stats.median)}</td>
                                <td>${formatTime(stats.min)} - ${formatTime(stats.max)}</td>
                            `;
                        }).join('')}
                    </tr>`;
                
                // Add example call types for ONVIEW, split by beat
                Object.keys(beatStats).forEach(beat => {
                    const examples = beatStats[beat].onviewExamples[priority];
                    if (examples && examples.size > 0) {
                        html += `
                            <tr class="expandable-row expandable-row-${priority} onview-row" style="font-size: 0.85em; color: #666;">
                                <td colspan="${1 + Object.keys(beatStats).length * 4}">
                                    <em>${beat} Examples: ${[...examples].slice(0, 4).join(' | ')}</em>
                                </td>
                            </tr>`;
                    }
                });
            });
            
            html += `
                    <tr>
                        <td><strong>Total Calls</strong></td>
                        ${Object.keys(beatStats).map(beat => `
                            <td colspan="4">${beatStats[beat].totalCalls.toLocaleString()}</td>
                        `).join('')}
                    </tr>
                </table>`;
            
            resultsDiv.innerHTML = html;
        }

        function openMapSelector() {
            console.log("Opening map selector modal");
            const modal = document.getElementById('mapModal');
            if (!modal) {
                console.error("Map modal element not found!");
                return;
            }
            modal.style.display = 'block';
            console.log("Calling initMap()");
            initMap();
            
            // Initialize selected beats from input
            const currentBeats = document.getElementById('dispatchBeat').value
                .split(',')
                .map(b => b.trim())
                .filter(b => b);
                
            console.log("Current beats from input:", currentBeats);
            selectedBeats = new Set(currentBeats);
            
            // Update map selections
            console.log("Updating map selections, available layers:", Object.keys(beatLayers));
            Object.entries(beatLayers).forEach(([beat, layer]) => {
                if (selectedBeats.has(beat)) {
                    layer.setStyle({ fillColor: '#00ff00', fillOpacity: 0.4 });
                } else {
                    layer.setStyle({ fillColor: '#3388ff', fillOpacity: 0.2 });
                }
            });
        }

        function closeMapSelector() {
            const modal = document.getElementById('mapModal');
            modal.style.display = 'none';
        }

        function toggleBeatSelection(beat, polygon) {
            if (selectedBeats.has(beat)) {
                selectedBeats.delete(beat);
                polygon.setStyle({ fillColor: '#3388ff', fillOpacity: 0.2 });
            } else {
                selectedBeats.add(beat);
                polygon.setStyle({ fillColor: '#00ff00', fillOpacity: 0.4 });
            }
        }

        function applyBeatSelection() {
            const dispatchBeatInput = document.getElementById('dispatchBeat');
            dispatchBeatInput.value = Array.from(selectedBeats).sort().join(', ');
            closeMapSelector();
        }

        async function initMap() {
            console.log("initMap called, map object exists:", !!map);
            if (!map) {
                console.log("Creating new map instance");
                
                const mapContainer = document.getElementById('map');
                if (!mapContainer) {
                    console.error("Map container element not found!");
                    return;
                }
                
                console.log("Map container dimensions:", mapContainer.offsetWidth, "x", mapContainer.offsetHeight);
                map = L.map('map').setView([47.6062, -122.3321], 11);
                console.log("Map object created:", map);
                
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '© OpenStreetMap contributors'
                }).addTo(map);
                console.log("Base tile layer added to map");

                try {
                    console.log("Attempting to fetch GeoJSON from:", 'beatmap.geojson');
                    let data;
                    
                    try {
                        const response = await fetch('beatmap.geojson');
                        console.log("Fetch response received:", response);
                        
                        if (!response.ok) {
                            console.error("Fetch error:", response.status, response.statusText);
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        
                        console.log("Parsing GeoJSON data");
                        data = await response.json();
                    } catch (fetchError) {
                        console.error("Failed to fetch GeoJSON:", fetchError);
                        console.log("Trying embedded minimal GeoJSON as fallback");
                        
                        // Minimal GeoJSON with just one SPD beat
                        data = {
                            "type": "FeatureCollection",
                            "features": [
                                {
                                    "type": "Feature",
                                    "properties": {
                                        "beat": "B1"
                                    },
                                    "geometry": {
                                        "type": "Polygon",
                                        "coordinates": [
                                            [
                                                [-122.33, 47.62],
                                                [-122.33, 47.63],
                                                [-122.32, 47.63],
                                                [-122.32, 47.62],
                                                [-122.33, 47.62]
                                            ]
                                        ]
                                    }
                                },
                                {
                                    "type": "Feature",
                                    "properties": {
                                        "beat": "B2"
                                    },
                                    "geometry": {
                                        "type": "Polygon",
                                        "coordinates": [
                                            [
                                                [-122.35, 47.64],
                                                [-122.35, 47.65],
                                                [-122.34, 47.65],
                                                [-122.34, 47.64],
                                                [-122.35, 47.64]
                                            ]
                                        ]
                                    }
                                }
                            ]
                        };
                    }
                    
                    console.log("GeoJSON parsed successfully, features:", data.features ? data.features.length : 'none');
                    
                    if (!data.features) {
                        console.error("No features found in GeoJSON data");
                        throw new Error('Invalid GeoJSON format or no features found');
                    }

                    // Analyze the structure of the first feature to help debugging
                    if (data.features.length > 0) {
                        const sample = data.features[0];
                        console.log("GEOJSON STRUCTURE ANALYSIS:");
                        console.log("Feature type:", sample.geometry.type);
                        console.log("Properties:", sample.properties);
                        console.log("First coordinate level:", Array.isArray(sample.geometry.coordinates) ? sample.geometry.coordinates.length : 'not array');
                        
                        if (Array.isArray(sample.geometry.coordinates) && sample.geometry.coordinates.length > 0) {
                            console.log("Second coordinate level:", Array.isArray(sample.geometry.coordinates[0]) ? sample.geometry.coordinates[0].length : 'not array');
                            
                            if (Array.isArray(sample.geometry.coordinates[0]) && sample.geometry.coordinates[0].length > 0) {
                                if (Array.isArray(sample.geometry.coordinates[0][0])) {
                                    console.log("Third coordinate level:", sample.geometry.coordinates[0][0].length);
                                    console.log("First 3 coordinates:", JSON.stringify(sample.geometry.coordinates[0].slice(0, 3)));
                                } else {
                                    console.log("Third coordinate level: not an array");
                                    console.log("First element of second level:", JSON.stringify(sample.geometry.coordinates[0]));
                                }
                            }
                        }
                    }

                    let featuresProcessed = 0;
                    let featuresAdded = 0;
                    
                    data.features.forEach((feature, index) => {
                        console.log(`Processing feature ${index + 1}/${data.features.length}`);
                        if (feature.geometry && feature.properties && feature.properties.beat) {
                            featuresProcessed++;
                            try {
                                const coordinates = feature.geometry.coordinates;
                                console.log(`Feature ${index + 1} has coordinates array:`, coordinates ? coordinates.length : 'none');
                                
                                if (!coordinates || !coordinates[0] || !Array.isArray(coordinates[0])) {
                                    console.error(`Invalid coordinates for beat ${feature.properties.beat}`);
                                    return;
                                }
                                
                                // Check coordinates structure and format appropriately
                                let latLngs;
                                if (coordinates[0] && Array.isArray(coordinates[0]) && coordinates[0].length > 0) {
                                    if (feature.geometry.type === "MultiPolygon") {
                                        // Handle MultiPolygon by processing all polygon rings
                                        latLngs = coordinates.map(polygon => 
                                            polygon[0].map(coord => [coord[1], coord[0]])
                                        );
                                    } else if (coordinates[0][0] && Array.isArray(coordinates[0][0]) && coordinates[0][0].length === 2) {
                                        // Normal polygon format
                                        latLngs = [coordinates[0].map(coord => [coord[1], coord[0]])];
                                    } else if (coordinates[0] && Array.isArray(coordinates[0]) && coordinates[0].length === 2) {
                                        // Single coordinate pair format
                                        console.warn(`Beat ${feature.properties.beat} has unusual coordinate structure. Attempting to fix...`);
                                        
                                        // Try to extract the full coordinates array
                                        const extractCoordinates = (coords, result = []) => {
                                            if (Array.isArray(coords)) {
                                                if (coords.length === 2 && typeof coords[0] === 'number' && typeof coords[1] === 'number') {
                                                    // This is a single [lng, lat] coordinate
                                                    result.push([coords[1], coords[0]]);
                                                } else {
                                                    // Recurse into nested arrays
                                                    coords.forEach(coord => extractCoordinates(coord, result));
                                                }
                                            }
                                            return result;
                                        };
                                        
                                        latLngs = [extractCoordinates(coordinates)];
                                    }
                                }
                                
                                if (!latLngs || !latLngs[0] || latLngs[0].length < 3) {
                                    console.error(`Not enough coordinates for beat ${feature.properties.beat}. Need at least 3 for a polygon.`);
                                    return;
                                }
                                
                                console.log(`Mapped ${latLngs.length} polygon(s) with ${latLngs[0].length} coordinate pairs for beat ${feature.properties.beat}`);
                                
                                const polygon = L.polygon(latLngs, {
                                    color: '#3388ff',
                                    weight: 2,
                                    fillOpacity: 0.2
                                }).addTo(map);

                                polygon.on('click', () => toggleBeatSelection(feature.properties.beat, polygon));
                                beatLayers[feature.properties.beat] = polygon;
                                featuresAdded++;
                                
                                // Add beat label
                                const center = polygon.getBounds().getCenter();
                                L.marker(center, {
                                    icon: L.divIcon({
                                        className: 'beat-label',
                                        html: `<div style="background-color: white; padding: 2px; border-radius: 2px;">${feature.properties.beat}</div>`
                                    })
                                }).addTo(map);
                                
                                console.log(`Successfully added beat ${feature.properties.beat} to map`);
                            } catch (e) {
                                console.error(`Error processing beat ${feature.properties.beat}:`, e);
                            }
                        } else {
                            console.warn(`Feature ${index + 1} missing required properties:`, 
                                         !feature.geometry ? 'No geometry' : 
                                         !feature.properties ? 'No properties' : 
                                         !feature.properties.beat ? 'No beat property' : 'Unknown issue');
                        }
                    });

                    console.log(`Processed ${featuresProcessed} features, added ${featuresAdded} to map`);
                    console.log(`Beat layers created:`, Object.keys(beatLayers));

                    if (Object.keys(beatLayers).length === 0) {
                        console.error("No beat layers created from GeoJSON");
                        throw new Error('No valid beats were loaded');
                    }

                } catch (error) {
                    console.error('Error loading beat data:', error);
                    const mapDiv = document.getElementById('map');
                    mapDiv.innerHTML = `
                        <div style="text-align: center; padding: 20px; color: #ff0000;">
                            <p>Error loading beat boundaries. Please try again later.</p>
                            <p>Error details: ${error.message}</p>
                            <p>Check your browser's console for more information.</p>
                        </div>
                    `;
                }
            } else {
                console.log("Using existing map instance");
                // Force map to update its size in case container changed
                map.invalidateSize();
            }
        }

        // Add this function after initMap
        function loadFallbackMap() {
            console.log("Loading fallback map with sample data");
            if (!map) {
                console.error("Map not initialized, cannot load fallback");
                return;
            }
            
            // Clear any error message
            const mapDiv = document.getElementById('map');
            mapDiv.innerHTML = '';
            
            // Sample beat data for testing
            const sampleBeats = [
                {
                    name: "B1",
                    coordinates: [
                        [
                            [47.62, -122.33],
                            [47.63, -122.33],
                            [47.63, -122.32],
                            [47.62, -122.32],
                            [47.62, -122.33]
                        ]
                    ]
                },
                {
                    name: "B2",
                    coordinates: [
                        [
                            [47.64, -122.35],
                            [47.65, -122.35],
                            [47.65, -122.34],
                            [47.64, -122.34],
                            [47.64, -122.35]
                        ]
                    ]
                }
            ];
            
            // Add sample beats to map
            sampleBeats.forEach(beat => {
                try {
                    console.log(`Adding sample beat ${beat.name}`);
                    
                    // Note: The sample coordinates are already in [lat, lng] format
                    const polygon = L.polygon(beat.coordinates[0], {
                        color: '#3388ff',
                        weight: 2,
                        fillOpacity: 0.2
                    }).addTo(map);
                    
                    polygon.on('click', () => toggleBeatSelection(beat.name, polygon));
                    beatLayers[beat.name] = polygon;
                    
                    // Add beat label at center
                    const bounds = polygon.getBounds();
                    const center = bounds.getCenter();
                    
                    L.marker(center, {
                        icon: L.divIcon({
                            className: 'beat-label',
                            html: `<div style="background-color: white; padding: 2px; border-radius: 2px;">${beat.name}</div>`
                        })
                    }).addTo(map);
                    
                    console.log(`Successfully added sample beat ${beat.name}`);
                } catch (e) {
                    console.error(`Error adding sample beat ${beat.name}:`, e);
                }
            });
            
            console.log("Fallback map loaded with sample beats:", Object.keys(beatLayers));
        }

        // Add a fallback button to the map modal
        document.addEventListener('DOMContentLoaded', function() {
            const modalContent = document.querySelector('.modal-content');
            if (modalContent) {
                const fallbackButton = document.createElement('button');
                fallbackButton.textContent = 'Try Fallback Map';
                fallbackButton.style.marginTop = '10px';
                fallbackButton.onclick = loadFallbackMap;
                
                const buttonContainer = document.createElement('div');
                buttonContainer.style.textAlign = 'center';
                buttonContainer.appendChild(fallbackButton);
                
                modalContent.appendChild(buttonContainer);
                console.log("Added fallback button to map modal");
            }
        });

        // Make sure Leaflet is loaded
        document.addEventListener('DOMContentLoaded', function() {
            console.log("DOM loaded, Leaflet available:", !!window.L);
        });

        // Add these functions at the end of the script
        function toggleMapDebug() {
            const debugSection = document.getElementById('map-debug');
            const isHidden = debugSection.style.display === 'none';
            debugSection.style.display = isHidden ? 'block' : 'none';
            
            if (isHidden) {
                updateMapDebug();
            }
        }
        
        function updateMapDebug() {
            const debugContent = document.getElementById('map-debug-content');
            if (!debugContent) return;
            
            const beatKeys = Object.keys(beatLayers);
            const mapExists = !!map;
            
            let html = `
                <p><strong>Map initialized:</strong> ${mapExists}</p>
                <p><strong>Beat layers loaded:</strong> ${beatKeys.length}</p>
                <p><strong>Beat IDs:</strong> ${beatKeys.join(', ') || 'None'}</p>
                <p><strong>Leaflet loaded:</strong> ${!!window.L}</p>
                <p><strong>Selected beats:</strong> ${Array.from(selectedBeats).join(', ') || 'None'}</p>
            `;
            
            debugContent.innerHTML = html;
        }
    </script>
</body>
</html>

