<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Response Time Lookup</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .input-group {
            margin-bottom: 20px;
        }
        .input-group label {
            margin-right: 10px;
        }
        .query-info {
            margin: 10px 0;
            padding: 10px;
            background-color: #f8f8f8;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
            display: none;
        }
        .show-query-btn {
            margin-left: 10px;
            padding: 5px 10px;
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
        }
        .show-query-btn:hover {
            background-color: #e0e0e0;
        }
        .table-container {
            width: 100%;
            overflow-x: auto;
            margin-bottom: 40px;
            /* Add smooth scrolling */
            scroll-behavior: smooth;
            /* Add some padding for better visibility */
            padding-bottom: 15px;
            /* Show scrollbar only when needed */
            scrollbar-width: auto;
            -webkit-overflow-scrolling: touch;
        }
        /* Style the scrollbar for webkit browsers */
        .table-container::-webkit-scrollbar {
            height: 12px;
        }
        .table-container::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 6px;
        }
        .table-container::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 6px;
        }
        .table-container::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        table {
            width: max-content;  /* Allow table to be wider than container */
            min-width: 100%;    /* But at least as wide as container */
            border-collapse: collapse;
            margin-top: 20px;
            border: 2px solid #000000;
        }
        th, td {
            padding: 10px;
            border: 1px solid #000000;
            text-align: left;
        }
        /* Bold borders between beat sections */
        td:nth-child(5), th:nth-child(5),
        td:nth-child(9), th:nth-child(9) {
            border-left: 2px solid #000000;
        }
        /* Bold border after Priority column - REMOVED for second table */
        td:first-child, th:first-child {
            border-right: 2px solid #000000;
        }
        /* Add new class for response time comparison table */
        .response-time-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            border: 2px solid #000000;
        }
        .response-time-table th, 
        .response-time-table td {
            padding: 10px;
            border: 1px solid #000000;
            text-align: left;
        }
        /* Set column widths */
        .response-time-table th:first-child { width: 15%; }
        .response-time-table th:nth-child(2) { width: 25%; }
        .response-time-table th:nth-child(3) { width: 30%; }
        .response-time-table th:nth-child(4) { width: 30%; }
        
        /* Priority group styling */
        .response-time-table tr.priority-group-start {
            border-top: 2px solid #000000;
        }
        .response-time-table tr:first-child {
            border-top: none;
        }
        .response-time-table thead tr {
            border-bottom: 2px solid #000000;
        }
        th {
            background-color: #f5f5f5;
            border-bottom: 2px solid #000000;
        }
        tr:nth-child(even) {
            background-color: transparent;
        }
        .priority-1 { background-color: rgba(232, 74, 95, 0.6) !important; }
        .priority-2 { background-color: rgba(239, 82, 87, 0.6) !important; }
        .priority-3 { background-color: rgba(245, 91, 79, 0.6) !important; }
        .priority-4 { background-color: rgba(250, 100, 70, 0.6) !important; }
        .priority-5 { background-color: rgba(253, 111, 60, 0.6) !important; }
        .priority-7 { background-color: rgba(255, 122, 48, 0.6) !important; }
        .priority-9 { background-color: rgba(255, 134, 34, 0.6) !important; }
        .loading {
            text-align: center;
            margin: 20px;
            font-style: italic;
            color: #666;
        }
        .error {
            text-align: center;
            margin: 20px;
            font-style: italic;
            color: #ff0000;
        }
        .expandable-button {
            cursor: pointer;
            padding: 2px 8px;
            margin-left: 8px;
            border: 1px solid #666;
            border-radius: 3px;
            background-color: #f8f8f8;
            font-weight: bold;
        }
        .expandable-button:hover {
            background-color: #e0e0e0;
        }
        .expandable-button:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
        /* Dynamic bold borders */
        .beat-section {
            border-left: 2px solid #000000;
        }
        .onview-row {
            background-color: #f8f8f8 !important;
        }
        .examples-row {
            font-size: 0.85em;
            color: #666;
            font-style: italic;
        }
        .backup-row { background-color: rgba(100, 149, 237, 0.1); }
        .backup-urgent-row { background-color: rgba(255, 140, 0, 0.1); }
        
        /* Map Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.4);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 800px;
            border-radius: 4px;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover {
            color: black;
        }

        #map {
            height: 600px;
            width: 100%;
            margin: 10px 0;
        }

        .map-button {
            margin-left: 10px;
            padding: 5px 10px;
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
        }

        .beat-label {
            background: none;
            border: none;
            box-shadow: none;
            font-weight: bold;
            text-shadow: 
                -1px -1px 0 #fff,
                1px -1px 0 #fff,
                -1px 1px 0 #fff,
                1px 1px 0 #fff;
            font-size: 14px;
            color: #000;
        }
        /* Update custom-button to match other buttons */
        .custom-button {
            display: inline-block;
            padding: 5px 10px;
            margin-left: 10px;
            font-size: inherit;
            font-weight: normal;
            text-align: center;
            text-decoration: none;
            color: white;
            background-color: #007bff;
            border-radius: 4px;
            border: 1px solid #0056b3;
            cursor: pointer;
        }
        .custom-button:hover {
            background-color: #0056b3;
        }
        .button-container {
            text-align: right;
            margin-top: 20px;
        }
        /* Add new styles for the call types button */
        .call-types-button {
            margin-left: 10px;
        }
    </style>
</head>
<body>
    <h2>Seattle Dispatch Response Time Lookup</h2>
    <div class="input-group">
        <label for="startDate">Start Date:</label>
        <input type="date" id="startDate">
        <label for="endDate">End Date:</label>
        <input type="date" id="endDate">
        <label for="dispatchBeat">Dispatch Beats (comma-separated):</label>
        <input type="text" id="dispatchBeat" placeholder="e.g., B1, C2">
        <button class="map-button" onclick="openMapSelector()">Select Dispatch Beat(s)<br>from Map</button>
        <button onclick="fetchData()">Get Response Times</button>
        <button class="show-query-btn" onclick="toggleQuery()">Show API Query</button>
        <a href="index.html" class="custom-button">Back to Map</a>
        <a href="calltypes.html" class="custom-button call-types-button">View Call Types by Priority</a>
    </div>
    
    <div id="query-display" class="query-info"></div>
    <div id="results"></div>

    <!-- Add Map Modal -->
    <div id="mapModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeMapSelector()">&times;</span>
            <h3>Select Beats from Map</h3>
            <div id="map"></div>
            <div style="margin-top: 10px; text-align: right;">
                <button onclick="applyBeatSelection()" style="margin-right: 10px;">Apply Selection</button>
                <button onclick="closeMapSelector()">Cancel</button>
            </div>
        </div>
    </div>

    <div class="button-container">
        <a href="index.html" class="custom-button">Back to Map</a>
    </div>

    <script>
        let currentQueries = [];
        const datasetId = "33kz-ixgy";
        const apiUrl = `https://data.seattle.gov/resource/${datasetId}.json`;
        let map = null;
        let beatLayers = {};
        let selectedBeats = new Set();

        function toggleQuery() {
            const queryDisplay = document.getElementById('query-display');
            if (queryDisplay.style.display === 'none' || !queryDisplay.style.display) {
                if (currentQueries.length > 0) {
                    queryDisplay.innerHTML = currentQueries.map((q, i) => 
                        `<strong>${i === 0 ? 'Count Query:' : 'Data Query:'}</strong>\n${apiUrl}${q}\n`
                    ).join('\n\n');
                    queryDisplay.style.display = 'block';
                } else {
                    queryDisplay.innerHTML = 'No queries have been made yet. Run a search first.';
                    queryDisplay.style.display = 'block';
                }
            } else {
                queryDisplay.style.display = 'none';
            }
        }

        async function fetchData() {
            currentQueries = []; // Reset queries
            const startDate = document.getElementById("startDate").value;
            const endDate = document.getElementById("endDate").value;
            const dispatchBeats = document.getElementById("dispatchBeat").value.toUpperCase().split(',').map(b => b.trim());
            
            if (!startDate || !endDate || dispatchBeats.length === 0 || dispatchBeats[0] === "") {
                alert("Please enter all fields.");
                return;
            }

            const resultsDiv = document.getElementById("results");
            resultsDiv.innerHTML = '<div class="loading">Calculating query size...</div>';
            
            let beatStats = {};
            let allData = [];

            // Get a rough count first
            let totalCount = 0;
            for (let beat of dispatchBeats) {
                const countQuery = `?$select=count(*) as count&$where=` +
                    `cad_event_original_time_queued >= '${startDate}T00:00:00' AND ` +
                    `cad_event_original_time_queued <= '${endDate}T23:59:59' AND ` +
                    `dispatch_beat='${beat}'`;
                
                currentQueries[0] = countQuery; // Store count query
                try {
                    const response = await fetch(apiUrl + countQuery);
                    const data = await response.json();
                    if (data && data[0] && data[0].count) {
                        const beatCount = Number(data[0].count);
                        totalCount += beatCount;
                        console.log(`Expected count for beat ${beat}: ${beatCount}`);
                    }
                } catch (error) {
                    console.warn("Count estimation failed, proceeding anyway");
                }
            }

            // Calculate rough time estimate (1 second per 1000 records plus API delays)
            if (totalCount > 0) {
                const estimatedSeconds = Math.ceil(totalCount / 1000) + 1;
                const startTime = Date.now();
                let totalProcessed = 0;
                let progressInterval;

                function updateProgress() {
                    const elapsedMs = Date.now() - startTime;
                    const elapsedSeconds = elapsedMs / 1000;
                    const progress = Math.min(100, (totalProcessed / totalCount) * 100);
                    
                    // Calculate remaining time based on current progress
                    const remainingSeconds = progress < 100 ? 
                        Math.ceil((estimatedSeconds * (100 - progress)) / 100) : 0;
                    const minutes = Math.floor(remainingSeconds / 60);
                    const seconds = Math.floor(remainingSeconds % 60);
                    const timeText = minutes > 0 ? 
                        `${minutes} minute${minutes > 1 ? 's' : ''} and ${seconds} second${seconds !== 1 ? 's' : ''}` : 
                        `${seconds} second${seconds !== 1 ? 's' : ''}`;

                    resultsDiv.innerHTML = `<div class="loading">
                        Fetching ${totalCount.toLocaleString()} records<br>
                        <small>Records processed: ${totalProcessed.toLocaleString()} / ${totalCount.toLocaleString()} (${Math.round(progress)}%)</small><br>
                        <small>Estimated time remaining: ${timeText}</small>
                        <div id="progress-container" style="width: 100%; background: #ddd; border-radius: 5px; overflow: hidden; margin-top: 5px;">
                            <div id="progress-bar" style="width: ${progress}%; height: 20px; background: #4CAF50; transition: width 0.5s linear;">
                                <div style="color: white; text-align: center; line-height: 20px; font-size: 12px; text-shadow: 1px 1px 2px rgba(0,0,0,0.5);">
                                    ${Math.round(progress)}%
                                </div>
                            </div>
                        </div>
                    </div>`;
                }

                // Initial display
                updateProgress();

                // Set up progress updates
                progressInterval = setInterval(updateProgress, 500);

                try {
                    for (let beat of dispatchBeats) {
                        let offset = 0;
                        let beatData = [];
                        let priorityGroups = {};
                        let specialGroups = {
                            ONVIEW: {},
                            BACKUP: {},
                            'BACKUP-URGENT': {}
                        };
                        
                        // Get total count for this beat for verification
                        let expectedCount = 0;
                        try {
                            const verifyQuery = `?$select=count(*) as count&$where=` +
                                `cad_event_original_time_queued >= '${startDate}T00:00:00' AND ` +
                                `cad_event_original_time_queued <= '${endDate}T23:59:59' AND ` +
                                `dispatch_beat='${beat}'`;
                            const response = await fetch(apiUrl + verifyQuery);
                            const data = await response.json();
                            if (data && data[0] && data[0].count) {
                                expectedCount = Number(data[0].count);
                                console.log(`Verified count for beat ${beat}: ${expectedCount}`);
                            }
                        } catch (error) {
                            console.warn(`Count verification failed for beat ${beat}:`, error);
                        }
                        
                        while (true) {
                            const query = `?$select=cad_event_original_time_queued,cad_event_first_response_time_s_,priority,call_type_indicator,final_call_type,dispatch_beat` +
                                `&$where=cad_event_original_time_queued >= '${startDate}T00:00:00' AND ` +
                                `cad_event_original_time_queued <= '${endDate}T23:59:59' AND ` +
                                `dispatch_beat='${beat}'` +
                                `&$limit=1000&$offset=${offset}` +
                                `&$order=cad_event_original_time_queued DESC`;
                            
                            if (offset === 0) {
                                currentQueries[1] = query;
                                console.log(`Initial query for beat ${beat}:`, apiUrl + query);
                            }

                            try {
                                const response = await fetch(apiUrl + query);
                                if (!response.ok) {
                                    console.error(`HTTP error for beat ${beat}:`, response.status, response.statusText);
                                    throw new Error(`HTTP error! status: ${response.status}`);
                                }
                                const data = await response.json();
                                console.log(`Received ${data?.length || 0} records for beat ${beat} at offset ${offset}`);
                                
                                if (!data || data.length === 0) break;
                                beatData = beatData.concat(data); // accumulate for this beat
                                allData = allData.concat(data);   // accumulate for all beats
                                offset += 1000;

                                totalProcessed += data.length;
                                updateProgress();

                                // Standard rate limiting delay
                                await new Promise(resolve => setTimeout(resolve, 1000));
                            } catch (error) {
                                console.error(`Error fetching data for beat ${beat}:`, error);
                                alert(`Failed to fetch data for beat ${beat}: ${error.message}`);
                                break;
                            }
                        }

                        // Process data for this beat
                        beatStats[beat] = processData(beatData, beat);
                    }
                } finally {
                    clearInterval(progressInterval);
                    // Show final processing message
                    resultsDiv.innerHTML = '<div class="loading">Processing results...</div>';
                    // Store allData in localStorage
                    console.log("About to save allData to localStorage. allData length:", allData.length, allData);
                    try {
                        localStorage.setItem('latestCallData', JSON.stringify(allData));
                        const stored = localStorage.getItem('latestCallData');
                        const sizeKB = stored ? (stored.length / 1024).toFixed(2) : 0;
                        const sizeMB = stored ? (stored.length / (1024*1024)).toFixed(2) : 0;
                        console.log(`localStorage.latestCallData: ${allData.length} records, ~${sizeKB} KB (~${sizeMB} MB)`);
                    } catch (e) {
                        console.error('Failed to store call data in localStorage:', e);
                    }
                    displayResults(beatStats);
                }
            } else {
                resultsDiv.innerHTML = '<div class="loading">Fetching data...</div>';
            }
        }
        
        function formatTime(seconds) {
            if (seconds === null || seconds === undefined) return 'N/A';
            
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            
            if (hours > 0) {
                return `${hours}h ${minutes}m ${secs}s`;
            } else if (minutes > 0) {
                return `${minutes}m ${secs}s`;
            } else {
                return `${secs}s`;
            }
        }
        
        function calculateStats(times) {
            if (!times || times.length === 0) {
                return {
                    count: 0,
                    mean: null,
                    median: null,
                    min: null,
                    max: null
                };
            }
            
            const sortedTimes = [...times].sort((a, b) => a - b);
            return {
                count: times.length,
                mean: times.reduce((a, b) => a + b, 0) / times.length,
                median: sortedTimes.length % 2 === 0 ? 
                    (sortedTimes[sortedTimes.length / 2 - 1] + sortedTimes[sortedTimes.length / 2]) / 2 :
                    sortedTimes[Math.floor(sortedTimes.length / 2)],
                min: sortedTimes[0],
                max: sortedTimes[sortedTimes.length - 1]
            };
        }

        function toggleRows(priority) {
            const rows = document.querySelectorAll(`.expandable-row-${priority}`);
            const button = document.querySelector(`#toggle-${priority}`);
            
            // Only proceed if we found expandable rows
            if (rows.length > 0) {
                const isExpanding = rows[0].style.display === 'none';
                
                rows.forEach(row => {
                    row.style.display = isExpanding ? 'table-row' : 'none';
                });
                
                if (button) {
                    button.textContent = isExpanding ? '-' : '+';
                }
            } else {
                // If no expandable rows found, disable the button
                if (button) {
                    button.disabled = true;
                    button.style.opacity = '0.5';
                    button.title = 'No ONVIEW data available';
                }
            }
        }
        
        function displayResults(beatStats) {
            console.log('Displaying results for beats:', Object.keys(beatStats), beatStats);
            const resultsDiv = document.getElementById("results");
            const beats = Object.keys(beatStats);
            
            // Get all priorities from both dispatch and ONVIEW
            const allPriorities = new Set();
            Object.values(beatStats).forEach(beat => {
                Object.keys(beat.priorities).forEach(p => allPriorities.add(p));
                Object.keys(beat.specialCategories.ONVIEW).forEach(p => allPriorities.add(p));
            });
            const sortedPriorities = [...allPriorities].sort((a, b) => Number(a) - Number(b));
            
            // Original table HTML generation
            let html = `
                <h3>Results (Dispatch Calls)</h3>
                <p style="color: #666; font-style: italic; margin-bottom: 20px;">
                    Showing official SPD response times for dispatch calls only. Response time is measured from call receipt to first unit arrival on scene. 
                    Click the + button next to each priority level to see officer-initiated (ONVIEW) calls.
                </p>
                <div class="table-container">
                    <table>
                        <tr>
                            <th>Priority</th>
                            ${beats.map((beat, i) => 
                                `<th colspan="4" class="${i > 0 ? 'beat-section' : ''}">${beat}</th>`
                            ).join('')}
                        </tr>
                        <tr>
                            <th></th>
                            ${beats.map((_, i) => `
                                <th class="${i > 0 ? 'beat-section' : ''}">Count</th>
                                <th>Mean</th>
                                <th>Median</th>
                                <th>Range</th>
                            `).join('')}
                        </tr>`;

            // Render each priority section in the main table
            sortedPriorities.forEach(priority => {
                const hasOnviewData = Object.values(beatStats).some(beat => 
                    beat.specialCategories.ONVIEW[priority] && 
                    beat.specialCategories.ONVIEW[priority].count > 0
                );
                html += renderPrioritySection(priority, beats, beatStats, hasOnviewData);
            });

            // Add total calls row to main table
            html += `
                <tr>
                    <td><strong>Total Calls</strong></td>
                    ${beats.map((beat, i) => {
                        const onviewCalls = Object.values(beatStats[beat].specialCategories.ONVIEW)
                            .reduce((sum, stats) => sum + (stats.totalCount || 0), 0);
                        const dispatchCalls = beatStats[beat].totalCalls - onviewCalls;
                        
                        return `<td colspan="4" class="${i > 0 ? 'beat-section' : ''}">
                            ${dispatchCalls.toLocaleString()}
                            ${onviewCalls > 0 ? 
                                `<span style="color: #666; font-style: italic; margin-left: 8px;"> [${onviewCalls.toLocaleString()} ONVIEW]</span>` 
                                : ''}
                        </td>`;
                    }).join('')}
                </tr>
            </table></div>`;

            // Add the response time comparison section with its own scrollable container
            html += `<div class="table-container">`;
            html += renderResponseTimeComparison(beatStats, beats, sortedPriorities);
            html += '</div>';
            
            resultsDiv.innerHTML = html;
        }

        function renderResponseTimeComparison(beatStats, beats, priorities) {
            // Prepare data structure for sorting
            const responseTimesByPriority = {};
            
            priorities.forEach(priority => {
                // Separate beats into those with and without valid response times
                const beatsWithTimes = [];
                const beatsWithoutTimes = [];
                
                beats.forEach(beat => {
                    const stats = beatStats[beat].priorities[priority];
                    if (!stats || !stats.validCount || stats.validCount === 0) {
                        // Store beats with no valid response times
                        beatsWithoutTimes.push({
                            beat,
                            count: stats?.totalCount || 0
                        });
                    } else {
                        beatsWithTimes.push({
                            beat,
                            mean: stats.mean,
                            median: stats.median,
                            count: stats.totalCount
                        });
                    }
                });
                
                // Sort beats with valid times by median response time
                beatsWithTimes.sort((a, b) => a.median - b.median);
                
                // Sort beats without times alphabetically
                beatsWithoutTimes.sort((a, b) => a.beat.localeCompare(b.beat));
                
                // Store both arrays for this priority
                responseTimesByPriority[priority] = {
                    withTimes: beatsWithTimes,
                    withoutTimes: beatsWithoutTimes
                };
            });

            let html = `
                <div style="margin-top: 40px;">
                    <h3>Response Time Comparison (Dispatch Calls Only)</h3>
                    <p style="color: #666; font-style: italic; margin-bottom: 20px;">
                        Beats are grouped by priority and sorted by median response time (fastest to slowest).
                        Beats with no valid response times are listed at the bottom of each priority group.
                    </p>
                    <table class="response-time-table">
                        <thead>
                            <tr>
                                <th>Priority</th>
                                <th>Beat</th>
                                <th>Median</th>
                                <th>Mean</th>
                            </tr>
                        </thead>
                        <tbody>`;

            priorities.forEach(priority => {
                const priorityData = responseTimesByPriority[priority];
                const totalRows = priorityData.withTimes.length + priorityData.withoutTimes.length;
                
                if (totalRows > 0) {
                    // Render beats with valid response times
                    priorityData.withTimes.forEach((stat, index) => {
                        html += `
                            <tr class="priority-${priority}${index === 0 ? ' priority-group-start' : ''}">
                                ${index === 0 ? `<td rowspan="${totalRows}"><strong>Priority ${priority}</strong></td>` : ''}
                                <td>${stat.beat} (${stat.count.toLocaleString()})</td>
                                <td>${formatTime(stat.median)}</td>
                                <td>${formatTime(stat.mean)}</td>
                            </tr>`;
                    });
                    
                    // Render beats without valid response times
                    priorityData.withoutTimes.forEach((stat, index) => {
                        const isFirstInGroup = index === 0 && priorityData.withTimes.length === 0;
                        html += `
                            <tr class="priority-${priority}${isFirstInGroup ? ' priority-group-start' : ''}">
                                ${isFirstInGroup ? `<td rowspan="${priorityData.withoutTimes.length}"><strong>Priority ${priority}</strong></td>` : ''}
                                <td>${stat.beat} (${stat.count.toLocaleString()})</td>
                                <td colspan="2" style="text-align: center;">No DISPATCH records</td>
                            </tr>`;
                    });
                }
            });

            html += '</tbody></table></div>';
            return html;
        }

        function processData(allData, beat) {
            console.log(`Processing ${allData.length} total records for beat ${beat}`);
            
            const stats = {
                totalCalls: 0,
                priorities: {},
                specialCategories: {
                    ONVIEW: {}
                },
                onviewExamples: {},
                allPriorities: new Set()
            };

            // First pass: count everything and collect valid response times
            allData.forEach((d, index) => {
                const priority = d.priority || 'unknown';
                const callType = d.call_type_indicator || 'unknown';
                const responseTime = d.cad_event_first_response_time_s_;
                
                // Track all priorities we encounter
                stats.allPriorities.add(priority);
                
                // Initialize containers if needed
                if (!stats.priorities[priority]) {
                    stats.priorities[priority] = {
                        totalCount: 0,          // Total records for this priority
                        validResponseTimes: [], // Array of valid response times for calculations
                        validCount: 0,          // Count of records with valid response times
                        noResponseTime: 0       // Count of records with no response time
                    };
                }
                if (!stats.specialCategories.ONVIEW[priority]) {
                    stats.specialCategories.ONVIEW[priority] = {
                        totalCount: 0,
                        validResponseTimes: [],
                        validCount: 0,
                        noResponseTime: 0
                    };
                }
                if (!stats.onviewExamples[priority]) {
                    stats.onviewExamples[priority] = new Set();
                }

                // Always increment total counts
                stats.totalCalls++;

                // Process record based on call type
                const processRecord = (container) => {
                    container.totalCount++; // Always increment total count
                    
                    if (responseTime === null || responseTime === undefined || responseTime === '') {
                        container.noResponseTime++;
                    } else {
                        const parsedTime = parseFloat(responseTime);
                        if (!isNaN(parsedTime) && parsedTime >= 0) {
                            container.validResponseTimes.push(parsedTime);
                            container.validCount++;
                        }
                    }
                };

                // Track call type counts and response times
                if (callType === 'ONVIEW') {
                    processRecord(stats.specialCategories.ONVIEW[priority]);
                    if (d.final_call_type) {
                        stats.onviewExamples[priority].add(d.final_call_type);
                    }
                } else if (callType === 'DISPATCH') {
                    processRecord(stats.priorities[priority]);
                }

                // Debug logging every 1000 records
                if (index % 1000 === 0) {
                    console.log(`Processing record ${index} for beat ${beat}:`, {
                        priority,
                        callType,
                        responseTime,
                        dispatchTotal: Object.values(stats.priorities).reduce((sum, p) => sum + p.totalCount, 0),
                        onviewTotal: Object.values(stats.specialCategories.ONVIEW).reduce((sum, p) => sum + p.totalCount, 0),
                        totalCalls: stats.totalCalls
                    });
                }
            });

            // After processing, log detailed breakdowns
            console.log(`=== Detailed Breakdown for beat ${beat} ===`);
            console.log('All priorities found:', [...stats.allPriorities].sort());
            console.log('Raw DISPATCH counts by priority:', Object.fromEntries(
                [...stats.allPriorities].map(p => [p, stats.priorities[p]?.totalCount || 0])
            ));
            console.log('Raw ONVIEW counts by priority:', Object.fromEntries(
                [...stats.allPriorities].map(p => [p, stats.specialCategories.ONVIEW[p]?.totalCount || 0])
            ));

            // Calculate statistics for all categories
            for (const priority in stats.priorities) {
                const container = stats.priorities[priority];
                const validTimes = container.validResponseTimes;
                
                // Calculate stats only from valid response times
                const statsData = validTimes.length > 0 ? calculateStats(validTimes) : {
                    mean: null,
                    median: null,
                    min: null,
                    max: null
                };
                
                // Keep all the original counts and add the stats
                stats.priorities[priority] = {
                    ...container,
                    ...statsData
                };
            }
            
            // Do the same for ONVIEW
            for (const priority in stats.specialCategories.ONVIEW) {
                const container = stats.specialCategories.ONVIEW[priority];
                const validTimes = container.validResponseTimes;
                
                const statsData = validTimes.length > 0 ? calculateStats(validTimes) : {
                    mean: null,
                    median: null,
                    min: null,
                    max: null
                };
                
                stats.specialCategories.ONVIEW[priority] = {
                    ...container,
                    ...statsData
                };
            }

            return stats;
        }

        function renderPrioritySection(priority, beats, beatStats, hasOnviewData) {
            console.log(`Rendering Priority ${priority} section, hasOnviewData:`, hasOnviewData);
            
            // Check if there are any dispatch records for this priority
            const hasDispatchRecords = beats.some(beat => 
                beatStats[beat].priorities[priority] && 
                beatStats[beat].priorities[priority].totalCount > 0
            );

            // Check if there are any ONVIEW records for this priority
            const hasOnviewRecords = beats.some(beat => 
                beatStats[beat].specialCategories.ONVIEW[priority] && 
                beatStats[beat].specialCategories.ONVIEW[priority].totalCount > 0
            );

            let html = `
                <tr class="priority-${priority}">
                    <td>
                        <strong>Priority ${priority}</strong>
                        ${hasOnviewRecords ? 
                            `<button id="toggle-${priority}" class="expandable-button" onclick="toggleRows('${priority}')">+</button>` 
                            : ''}
                    </td>
                    ${beats.map((beat, i) => {
                        const stats = beatStats[beat].priorities[priority];
                        
                        // Debug logging for this specific beat and priority
                        console.log(`Beat ${beat} Priority ${priority} raw stats:`, {
                            totalCount: stats?.totalCount || 0,
                            validCount: stats?.validCount || 0,
                            noResponseTime: stats?.noResponseTime || 0
                        });
                        
                        if (!stats || stats.totalCount === 0) 
                            return `<td colspan="4" class="${i > 0 ? 'beat-section' : ''}">${hasOnviewRecords ? 'No DISPATCH records' : 'No records'}</td>`;
                        
                        // Always use totalCount for display
                        const displayCount = stats.totalCount;
                        const hasValidTimes = stats.validCount > 0;
                        
                        return `
                            <td class="${i > 0 ? 'beat-section' : ''}">${displayCount.toLocaleString()}</td>
                            <td>${hasValidTimes ? formatTime(stats.mean) : 'N/A'}</td>
                            <td>${hasValidTimes ? formatTime(stats.median) : 'N/A'}</td>
                            <td>${hasValidTimes ? `${formatTime(stats.min)} - ${formatTime(stats.max)}` : 'N/A'}</td>
                        `;
                    }).join('')}
                </tr>`;

            // Always render ONVIEW rows if there are any ONVIEW records
            if (hasOnviewRecords) {
                html += renderOnviewRows(priority, beats, beatStats);
            }

            return html;
        }

        function renderOnviewRows(priority, beats, beatStats) {
            console.log(`Rendering ONVIEW rows for Priority ${priority}`);
            
            let html = `
                <tr class="expandable-row expandable-row-${priority} onview-row" style="display: none;">
                    <td>ONVIEW</td>
                    ${beats.map((beat, i) => {
                        const stats = beatStats[beat].specialCategories.ONVIEW[priority];
                        
                        // Debug
                        console.log(`Beat ${beat} Priority ${priority} ONVIEW stats:`, stats);
                        
                        if (!stats || stats.totalCount === 0) 
                            return `<td colspan="4" class="${i > 0 ? 'beat-section' : ''}">No ONVIEW records</td>`;
                        
                        const hasValidTimes = stats.validCount > 0;
                        
                        return `
                            <td class="${i > 0 ? 'beat-section' : ''}">${stats.totalCount.toLocaleString()}</td>
                            <td>${hasValidTimes ? formatTime(stats.mean) : 'N/A'}</td>
                            <td>${hasValidTimes ? formatTime(stats.median) : 'N/A'}</td>
                            <td>${hasValidTimes ? `${formatTime(stats.min)} - ${formatTime(stats.max)}` : 'N/A'}</td>
                        `;
                    }).join('')}
                </tr>`;

            const examples = Object.entries(beatStats)
                .filter(([_, beat]) => beat.onviewExamples[priority]?.size > 0)
                .map(([beat, data]) => `${beat}: ${[...data.onviewExamples[priority]].slice(0, 4).join(' | ')}`)
                .join(' | ');

            if (examples) {
                html += `
                    <tr class="expandable-row expandable-row-${priority} onview-row examples-row" style="display: none;">
                        <td colspan="${1 + beats.length * 4}">
                            Onview Examples: ${examples}
                        </td>
                    </tr>`;
            }

            return html;
        }

        function openMapSelector() {
            console.log("Opening map selector modal");
            const modal = document.getElementById('mapModal');
            if (!modal) {
                console.error("Map modal element not found!");
                return;
            }
            modal.style.display = 'block';
            console.log("Calling initMap()");
            initMap();
            
            // Initialize selected beats from input
            const currentBeats = document.getElementById('dispatchBeat').value
                .split(',')
                .map(b => b.trim())
                .filter(b => b);
                
            console.log("Current beats from input:", currentBeats);
            selectedBeats = new Set(currentBeats);
            
            // Update map selections
            console.log("Updating map selections, available layers:", Object.keys(beatLayers));
            Object.entries(beatLayers).forEach(([beat, layer]) => {
                if (selectedBeats.has(beat)) {
                    layer.setStyle({ fillColor: '#00ff00', fillOpacity: 0.4 });
                } else {
                    layer.setStyle({ fillColor: '#3388ff', fillOpacity: 0.2 });
                }
            });
        }

        function closeMapSelector() {
            const modal = document.getElementById('mapModal');
            modal.style.display = 'none';
        }

        function toggleBeatSelection(beat, polygon) {
            if (selectedBeats.has(beat)) {
                selectedBeats.delete(beat);
                polygon.setStyle({ fillColor: '#3388ff', fillOpacity: 0.2 });
            } else {
                selectedBeats.add(beat);
                polygon.setStyle({ fillColor: '#00ff00', fillOpacity: 0.4 });
            }
        }

        function applyBeatSelection() {
            const dispatchBeatInput = document.getElementById('dispatchBeat');
            dispatchBeatInput.value = Array.from(selectedBeats).sort().join(', ');
            closeMapSelector();
        }

        async function initMap() {
            console.log("initMap called, map object exists:", !!map);
            if (!map) {
                console.log("Creating new map instance");
                
                const mapContainer = document.getElementById('map');
                if (!mapContainer) {
                    console.error("Map container element not found!");
                    return;
                }
                
                console.log("Map container dimensions:", mapContainer.offsetWidth, "x", mapContainer.offsetHeight);
                map = L.map('map').setView([47.6062, -122.3321], 11);
                console.log("Map object created:", map);
                
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: 'Â© OpenStreetMap contributors'
                }).addTo(map);
                console.log("Base tile layer added to map");

                try {
                    console.log("Attempting to fetch GeoJSON from:", 'beatmap.geojson');
                    let data;
                    
                    try {
                        const response = await fetch('beatmap.geojson');
                        console.log("Fetch response received:", response);
                        
                        if (!response.ok) {
                            console.error("Fetch error:", response.status, response.statusText);
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        
                        console.log("Parsing GeoJSON data");
                        data = await response.json();
                    } catch (fetchError) {
                        console.error("Failed to fetch GeoJSON:", fetchError);
                        console.log("Trying embedded minimal GeoJSON as fallback");
                        
                        // Minimal GeoJSON with just one SPD beat
                        data = {
                            "type": "FeatureCollection",
                            "features": [
                                {
                                    "type": "Feature",
                                    "properties": {
                                        "beat": "B1"
                                    },
                                    "geometry": {
                                        "type": "Polygon",
                                        "coordinates": [
                                            [
                                                [-122.33, 47.62],
                                                [-122.33, 47.63],
                                                [-122.32, 47.63],
                                                [-122.32, 47.62],
                                                [-122.33, 47.62]
                                            ]
                                        ]
                                    }
                                },
                                {
                                    "type": "Feature",
                                    "properties": {
                                        "beat": "B2"
                                    },
                                    "geometry": {
                                        "type": "Polygon",
                                        "coordinates": [
                                            [
                                                [-122.35, 47.64],
                                                [-122.35, 47.65],
                                                [-122.34, 47.65],
                                                [-122.34, 47.64],
                                                [-122.35, 47.64]
                                            ]
                                        ]
                                    }
                                }
                            ]
                        };
                    }
                    
                    console.log("GeoJSON parsed successfully, features:", data.features ? data.features.length : 'none');
                    
                    if (!data.features) {
                        console.error("No features found in GeoJSON data");
                        throw new Error('Invalid GeoJSON format or no features found');
                    }

                    // Analyze the structure of the first feature to help debugging
                    if (data.features.length > 0) {
                        const sample = data.features[0];
                        console.log("GEOJSON STRUCTURE ANALYSIS:");
                        console.log("Feature type:", sample.geometry.type);
                        console.log("Properties:", sample.properties);
                        console.log("First coordinate level:", Array.isArray(sample.geometry.coordinates) ? sample.geometry.coordinates.length : 'not array');
                        
                        if (Array.isArray(sample.geometry.coordinates) && sample.geometry.coordinates.length > 0) {
                            console.log("Second coordinate level:", Array.isArray(sample.geometry.coordinates[0]) ? sample.geometry.coordinates[0].length : 'not array');
                            
                            if (Array.isArray(sample.geometry.coordinates[0]) && sample.geometry.coordinates[0].length > 0) {
                                if (Array.isArray(sample.geometry.coordinates[0][0])) {
                                    console.log("Third coordinate level:", sample.geometry.coordinates[0][0].length);
                                    console.log("First 3 coordinates:", JSON.stringify(sample.geometry.coordinates[0].slice(0, 3)));
                                } else {
                                    console.log("Third coordinate level: not an array");
                                    console.log("First element of second level:", JSON.stringify(sample.geometry.coordinates[0]));
                                }
                            }
                        }
                    }

                    let featuresProcessed = 0;
                    let featuresAdded = 0;
                    
                    data.features.forEach((feature, index) => {
                        console.log(`Processing feature ${index + 1}/${data.features.length}`);
                        if (feature.geometry && feature.properties && feature.properties.beat) {
                            featuresProcessed++;
                            try {
                                const coordinates = feature.geometry.coordinates;
                                console.log(`Feature ${index + 1} has coordinates array:`, coordinates ? coordinates.length : 'none');
                                
                                if (!coordinates || !coordinates[0] || !Array.isArray(coordinates[0])) {
                                    console.error(`Invalid coordinates for beat ${feature.properties.beat}`);
                                    return;
                                }
                                
                                // Check coordinates structure and format appropriately
                                let latLngs;
                                if (coordinates[0] && Array.isArray(coordinates[0]) && coordinates[0].length > 0) {
                                    if (feature.geometry.type === "MultiPolygon") {
                                        // Handle MultiPolygon by processing all polygon rings
                                        latLngs = coordinates.map(polygon => 
                                            polygon[0].map(coord => [coord[1], coord[0]])
                                        );
                                    } else if (coordinates[0][0] && Array.isArray(coordinates[0][0]) && coordinates[0][0].length === 2) {
                                        // Normal polygon format
                                        latLngs = [coordinates[0].map(coord => [coord[1], coord[0]])];
                                    } else if (coordinates[0] && Array.isArray(coordinates[0]) && coordinates[0].length === 2) {
                                        // Single coordinate pair format
                                        console.warn(`Beat ${feature.properties.beat} has unusual coordinate structure. Attempting to fix...`);
                                        
                                        // Try to extract the full coordinates array
                                        const extractCoordinates = (coords, result = []) => {
                                            if (Array.isArray(coords)) {
                                                if (coords.length === 2 && typeof coords[0] === 'number' && typeof coords[1] === 'number') {
                                                    // This is a single [lng, lat] coordinate
                                                    result.push([coords[1], coords[0]]);
                                                } else {
                                                    // Recurse into nested arrays
                                                    coords.forEach(coord => extractCoordinates(coord, result));
                                                }
                                            }
                                            return result;
                                        };
                                        
                                        latLngs = [extractCoordinates(coordinates)];
                                    }
                                }
                                
                                if (!latLngs || !latLngs[0] || latLngs[0].length < 3) {
                                    console.error(`Not enough coordinates for beat ${feature.properties.beat}. Need at least 3 for a polygon.`);
                                    return;
                                }
                                
                                console.log(`Mapped ${latLngs.length} polygon(s) with ${latLngs[0].length} coordinate pairs for beat ${feature.properties.beat}`);
                                
                                const polygon = L.polygon(latLngs, {
                                    color: '#3388ff',
                                    weight: 2,
                                    fillOpacity: 0.2
                                }).addTo(map);

                                polygon.on('click', () => toggleBeatSelection(feature.properties.beat, polygon));
                                beatLayers[feature.properties.beat] = polygon;
                                featuresAdded++;
                                
                                // Add beat label at center
                                const center = polygon.getBounds().getCenter();
                                L.marker(center, {
                                    icon: L.divIcon({
                                        className: 'beat-label',
                                        html: feature.properties.beat,
                                        iconSize: null,
                                        iconAnchor: [15, 0]
                                    })
                                }).addTo(map);
                                
                                console.log(`Successfully added beat ${feature.properties.beat} to map`);
                            } catch (e) {
                                console.error(`Error processing beat ${feature.properties.beat}:`, e);
                            }
                        } else {
                            console.warn(`Feature ${index + 1} missing required properties:`, 
                                         !feature.geometry ? 'No geometry' : 
                                         !feature.properties ? 'No properties' : 
                                         !feature.properties.beat ? 'No beat property' : 'Unknown issue');
                        }
                    });

                    console.log(`Processed ${featuresProcessed} features, added ${featuresAdded} to map`);
                    console.log(`Beat layers created:`, Object.keys(beatLayers));

                    if (Object.keys(beatLayers).length === 0) {
                        console.error("No beat layers created from GeoJSON");
                        throw new Error('No valid beats were loaded');
                    }

                } catch (error) {
                    console.error('Error loading beat data:', error);
                    const mapDiv = document.getElementById('map');
                    mapDiv.innerHTML = `
                        <div style="text-align: center; padding: 20px; color: #ff0000;">
                            <p>Error loading beat boundaries. Please try again later.</p>
                            <p>Error details: ${error.message}</p>
                            <p>Check your browser's console for more information.</p>
                        </div>
                    `;
                }
            } else {
                console.log("Using existing map instance");
                // Force map to update its size in case container changed
                map.invalidateSize();
            }
        }

        // Add this function after initMap
        function loadFallbackMap() {
            console.log("Loading fallback map with sample data");
            if (!map) {
                console.error("Map not initialized, cannot load fallback");
                return;
            }
            
            // Clear any error message
            const mapDiv = document.getElementById('map');
            mapDiv.innerHTML = '';
            
            // Sample beat data for testing
            const sampleBeats = [
                {
                    name: "B1",
                    coordinates: [
                        [
                            [47.62, -122.33],
                            [47.63, -122.33],
                            [47.63, -122.32],
                            [47.62, -122.32],
                            [47.62, -122.33]
                        ]
                    ]
                },
                {
                    name: "B2",
                    coordinates: [
                        [
                            [47.64, -122.35],
                            [47.65, -122.35],
                            [47.65, -122.34],
                            [47.64, -122.34],
                            [47.64, -122.35]
                        ]
                    ]
                }
            ];
            
            // Add sample beats to map
            sampleBeats.forEach(beat => {
                try {
                    console.log(`Adding sample beat ${beat.name}`);
                    
                    // Note: The sample coordinates are already in [lat, lng] format
                    const polygon = L.polygon(beat.coordinates[0], {
                        color: '#3388ff',
                        weight: 2,
                        fillOpacity: 0.2
                    }).addTo(map);
                    
                    polygon.on('click', () => toggleBeatSelection(beat.name, polygon));
                    beatLayers[beat.name] = polygon;
                    
                    // Add beat label at center
                    const bounds = polygon.getBounds();
                    const center = bounds.getCenter();
                    
                    L.marker(center, {
                        icon: L.divIcon({
                            className: 'beat-label',
                            html: `<div style="background-color: white; padding: 2px; border-radius: 2px;">${beat.name}</div>`
                        })
                    }).addTo(map);
                    
                    console.log(`Successfully added sample beat ${beat.name}`);
                } catch (e) {
                    console.error(`Error adding sample beat ${beat.name}:`, e);
                }
            });
            
            console.log("Fallback map loaded with sample beats:", Object.keys(beatLayers));
        }

        // Add a fallback button to the map modal
        document.addEventListener('DOMContentLoaded', function() {
            const modalContent = document.querySelector('.modal-content');
            if (modalContent) {
                const fallbackButton = document.createElement('button');
                fallbackButton.textContent = 'Try Fallback Map';
                fallbackButton.style.marginTop = '10px';
                fallbackButton.onclick = loadFallbackMap;
                
                const buttonContainer = document.createElement('div');
                buttonContainer.style.textAlign = 'center';
                buttonContainer.appendChild(fallbackButton);
                
                modalContent.appendChild(buttonContainer);
                console.log("Added fallback button to map modal");
            }
        });

        // Make sure Leaflet is loaded
        document.addEventListener('DOMContentLoaded', function() {
            console.log("DOM loaded, Leaflet available:", !!window.L);
        });

        // Add these functions at the end of the script
        function toggleMapDebug() {
            const debugSection = document.getElementById('map-debug');
            const isHidden = debugSection.style.display === 'none';
            debugSection.style.display = isHidden ? 'block' : 'none';
            
            if (isHidden) {
                updateMapDebug();
            }
        }
        
        function updateMapDebug() {
            const debugContent = document.getElementById('map-debug-content');
            if (!debugContent) return;
            
            const beatKeys = Object.keys(beatLayers);
            const mapExists = !!map;
            
            let html = `
                <p><strong>Map initialized:</strong> ${mapExists}</p>
                <p><strong>Beat layers loaded:</strong> ${beatKeys.length}</p>
                <p><strong>Beat IDs:</strong> ${beatKeys.join(', ') || 'None'}</p>
                <p><strong>Leaflet loaded:</strong> ${!!window.L}</p>
                <p><strong>Selected beats:</strong> ${Array.from(selectedBeats).join(', ') || 'None'}</p>
            `;
            
            debugContent.innerHTML = html;
        }

        window.onload = function() {
            // Try to load previous results from localStorage
            const previousData = JSON.parse(localStorage.getItem('latestCallData') || '[]');
            if (previousData.length) {
                // Reconstruct beatStats from previousData
                // Group by beat
                let beatStats = {};
                previousData.forEach(record => {
                    const beat = record.dispatch_beat || 'Unknown';
                    if (!beatStats[beat]) beatStats[beat] = [];
                    beatStats[beat].push(record);
                });
                // Process each beat's data
                let processedStats = {};
                for (const beat in beatStats) {
                    processedStats[beat] = processData(beatStats[beat], beat);
                }
                displayResults(processedStats);
            }
        };
    </script>
</body>
</html>

